module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateInterview {
  count: Int!
}

type AggregateReview {
  count: Int!
}

type AggregateSauce {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

type Interview {
  id: ID!
  title: String!
  host: String!
  guest: String!
  season: Int!
  episode: Int!
  airDate: DateTime!
  sauces(where: SauceWhereInput, orderBy: SauceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sauce!]
  link: String!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
}

type InterviewConnection {
  pageInfo: PageInfo!
  edges: [InterviewEdge]!
  aggregate: AggregateInterview!
}

input InterviewCreateInput {
  id: ID
  title: String!
  host: String
  guest: String!
  season: Int!
  episode: Int!
  airDate: DateTime!
  sauces: SauceCreateManyWithoutAppearsInInput
  link: String!
  reviews: ReviewCreateManyWithoutInterviewInput
}

input InterviewCreateManyWithoutSaucesInput {
  create: [InterviewCreateWithoutSaucesInput!]
  connect: [InterviewWhereUniqueInput!]
}

input InterviewCreateOneWithoutReviewsInput {
  create: InterviewCreateWithoutReviewsInput
  connect: InterviewWhereUniqueInput
}

input InterviewCreateWithoutReviewsInput {
  id: ID
  title: String!
  host: String
  guest: String!
  season: Int!
  episode: Int!
  airDate: DateTime!
  sauces: SauceCreateManyWithoutAppearsInInput
  link: String!
}

input InterviewCreateWithoutSaucesInput {
  id: ID
  title: String!
  host: String
  guest: String!
  season: Int!
  episode: Int!
  airDate: DateTime!
  link: String!
  reviews: ReviewCreateManyWithoutInterviewInput
}

type InterviewEdge {
  node: Interview!
  cursor: String!
}

enum InterviewOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  host_ASC
  host_DESC
  guest_ASC
  guest_DESC
  season_ASC
  season_DESC
  episode_ASC
  episode_DESC
  airDate_ASC
  airDate_DESC
  link_ASC
  link_DESC
}

type InterviewPreviousValues {
  id: ID!
  title: String!
  host: String!
  guest: String!
  season: Int!
  episode: Int!
  airDate: DateTime!
  link: String!
}

input InterviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  host: String
  host_not: String
  host_in: [String!]
  host_not_in: [String!]
  host_lt: String
  host_lte: String
  host_gt: String
  host_gte: String
  host_contains: String
  host_not_contains: String
  host_starts_with: String
  host_not_starts_with: String
  host_ends_with: String
  host_not_ends_with: String
  guest: String
  guest_not: String
  guest_in: [String!]
  guest_not_in: [String!]
  guest_lt: String
  guest_lte: String
  guest_gt: String
  guest_gte: String
  guest_contains: String
  guest_not_contains: String
  guest_starts_with: String
  guest_not_starts_with: String
  guest_ends_with: String
  guest_not_ends_with: String
  season: Int
  season_not: Int
  season_in: [Int!]
  season_not_in: [Int!]
  season_lt: Int
  season_lte: Int
  season_gt: Int
  season_gte: Int
  episode: Int
  episode_not: Int
  episode_in: [Int!]
  episode_not_in: [Int!]
  episode_lt: Int
  episode_lte: Int
  episode_gt: Int
  episode_gte: Int
  airDate: DateTime
  airDate_not: DateTime
  airDate_in: [DateTime!]
  airDate_not_in: [DateTime!]
  airDate_lt: DateTime
  airDate_lte: DateTime
  airDate_gt: DateTime
  airDate_gte: DateTime
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  AND: [InterviewScalarWhereInput!]
  OR: [InterviewScalarWhereInput!]
  NOT: [InterviewScalarWhereInput!]
}

type InterviewSubscriptionPayload {
  mutation: MutationType!
  node: Interview
  updatedFields: [String!]
  previousValues: InterviewPreviousValues
}

input InterviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InterviewWhereInput
  AND: [InterviewSubscriptionWhereInput!]
  OR: [InterviewSubscriptionWhereInput!]
  NOT: [InterviewSubscriptionWhereInput!]
}

input InterviewUpdateInput {
  title: String
  host: String
  guest: String
  season: Int
  episode: Int
  airDate: DateTime
  sauces: SauceUpdateManyWithoutAppearsInInput
  link: String
  reviews: ReviewUpdateManyWithoutInterviewInput
}

input InterviewUpdateManyDataInput {
  title: String
  host: String
  guest: String
  season: Int
  episode: Int
  airDate: DateTime
  link: String
}

input InterviewUpdateManyMutationInput {
  title: String
  host: String
  guest: String
  season: Int
  episode: Int
  airDate: DateTime
  link: String
}

input InterviewUpdateManyWithoutSaucesInput {
  create: [InterviewCreateWithoutSaucesInput!]
  delete: [InterviewWhereUniqueInput!]
  connect: [InterviewWhereUniqueInput!]
  set: [InterviewWhereUniqueInput!]
  disconnect: [InterviewWhereUniqueInput!]
  update: [InterviewUpdateWithWhereUniqueWithoutSaucesInput!]
  upsert: [InterviewUpsertWithWhereUniqueWithoutSaucesInput!]
  deleteMany: [InterviewScalarWhereInput!]
  updateMany: [InterviewUpdateManyWithWhereNestedInput!]
}

input InterviewUpdateManyWithWhereNestedInput {
  where: InterviewScalarWhereInput!
  data: InterviewUpdateManyDataInput!
}

input InterviewUpdateOneRequiredWithoutReviewsInput {
  create: InterviewCreateWithoutReviewsInput
  update: InterviewUpdateWithoutReviewsDataInput
  upsert: InterviewUpsertWithoutReviewsInput
  connect: InterviewWhereUniqueInput
}

input InterviewUpdateWithoutReviewsDataInput {
  title: String
  host: String
  guest: String
  season: Int
  episode: Int
  airDate: DateTime
  sauces: SauceUpdateManyWithoutAppearsInInput
  link: String
}

input InterviewUpdateWithoutSaucesDataInput {
  title: String
  host: String
  guest: String
  season: Int
  episode: Int
  airDate: DateTime
  link: String
  reviews: ReviewUpdateManyWithoutInterviewInput
}

input InterviewUpdateWithWhereUniqueWithoutSaucesInput {
  where: InterviewWhereUniqueInput!
  data: InterviewUpdateWithoutSaucesDataInput!
}

input InterviewUpsertWithoutReviewsInput {
  update: InterviewUpdateWithoutReviewsDataInput!
  create: InterviewCreateWithoutReviewsInput!
}

input InterviewUpsertWithWhereUniqueWithoutSaucesInput {
  where: InterviewWhereUniqueInput!
  update: InterviewUpdateWithoutSaucesDataInput!
  create: InterviewCreateWithoutSaucesInput!
}

input InterviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  host: String
  host_not: String
  host_in: [String!]
  host_not_in: [String!]
  host_lt: String
  host_lte: String
  host_gt: String
  host_gte: String
  host_contains: String
  host_not_contains: String
  host_starts_with: String
  host_not_starts_with: String
  host_ends_with: String
  host_not_ends_with: String
  guest: String
  guest_not: String
  guest_in: [String!]
  guest_not_in: [String!]
  guest_lt: String
  guest_lte: String
  guest_gt: String
  guest_gte: String
  guest_contains: String
  guest_not_contains: String
  guest_starts_with: String
  guest_not_starts_with: String
  guest_ends_with: String
  guest_not_ends_with: String
  season: Int
  season_not: Int
  season_in: [Int!]
  season_not_in: [Int!]
  season_lt: Int
  season_lte: Int
  season_gt: Int
  season_gte: Int
  episode: Int
  episode_not: Int
  episode_in: [Int!]
  episode_not_in: [Int!]
  episode_lt: Int
  episode_lte: Int
  episode_gt: Int
  episode_gte: Int
  airDate: DateTime
  airDate_not: DateTime
  airDate_in: [DateTime!]
  airDate_not_in: [DateTime!]
  airDate_lt: DateTime
  airDate_lte: DateTime
  airDate_gt: DateTime
  airDate_gte: DateTime
  sauces_every: SauceWhereInput
  sauces_some: SauceWhereInput
  sauces_none: SauceWhereInput
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  AND: [InterviewWhereInput!]
  OR: [InterviewWhereInput!]
  NOT: [InterviewWhereInput!]
}

input InterviewWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createInterview(data: InterviewCreateInput!): Interview!
  updateInterview(data: InterviewUpdateInput!, where: InterviewWhereUniqueInput!): Interview
  updateManyInterviews(data: InterviewUpdateManyMutationInput!, where: InterviewWhereInput): BatchPayload!
  upsertInterview(where: InterviewWhereUniqueInput!, create: InterviewCreateInput!, update: InterviewUpdateInput!): Interview!
  deleteInterview(where: InterviewWhereUniqueInput!): Interview
  deleteManyInterviews(where: InterviewWhereInput): BatchPayload!
  createReview(data: ReviewCreateInput!): Review!
  updateReview(data: ReviewUpdateInput!, where: ReviewWhereUniqueInput!): Review
  updateManyReviews(data: ReviewUpdateManyMutationInput!, where: ReviewWhereInput): BatchPayload!
  upsertReview(where: ReviewWhereUniqueInput!, create: ReviewCreateInput!, update: ReviewUpdateInput!): Review!
  deleteReview(where: ReviewWhereUniqueInput!): Review
  deleteManyReviews(where: ReviewWhereInput): BatchPayload!
  createSauce(data: SauceCreateInput!): Sauce!
  updateSauce(data: SauceUpdateInput!, where: SauceWhereUniqueInput!): Sauce
  updateManySauces(data: SauceUpdateManyMutationInput!, where: SauceWhereInput): BatchPayload!
  upsertSauce(where: SauceWhereUniqueInput!, create: SauceCreateInput!, update: SauceUpdateInput!): Sauce!
  deleteSauce(where: SauceWhereUniqueInput!): Sauce
  deleteManySauces(where: SauceWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  interview(where: InterviewWhereUniqueInput!): Interview
  interviews(where: InterviewWhereInput, orderBy: InterviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interview]!
  interviewsConnection(where: InterviewWhereInput, orderBy: InterviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InterviewConnection!
  review(where: ReviewWhereUniqueInput!): Review
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review]!
  reviewsConnection(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReviewConnection!
  sauce(where: SauceWhereUniqueInput!): Sauce
  sauces(where: SauceWhereInput, orderBy: SauceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sauce]!
  saucesConnection(where: SauceWhereInput, orderBy: SauceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SauceConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Review {
  id: ID!
  stars: Int!
  commentary: String
  author: User!
  interview: Interview!
}

type ReviewConnection {
  pageInfo: PageInfo!
  edges: [ReviewEdge]!
  aggregate: AggregateReview!
}

input ReviewCreateInput {
  id: ID
  stars: Int!
  commentary: String
  author: UserCreateOneWithoutReviewsInput!
  interview: InterviewCreateOneWithoutReviewsInput!
}

input ReviewCreateManyWithoutAuthorInput {
  create: [ReviewCreateWithoutAuthorInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateManyWithoutInterviewInput {
  create: [ReviewCreateWithoutInterviewInput!]
  connect: [ReviewWhereUniqueInput!]
}

input ReviewCreateWithoutAuthorInput {
  id: ID
  stars: Int!
  commentary: String
  interview: InterviewCreateOneWithoutReviewsInput!
}

input ReviewCreateWithoutInterviewInput {
  id: ID
  stars: Int!
  commentary: String
  author: UserCreateOneWithoutReviewsInput!
}

type ReviewEdge {
  node: Review!
  cursor: String!
}

enum ReviewOrderByInput {
  id_ASC
  id_DESC
  stars_ASC
  stars_DESC
  commentary_ASC
  commentary_DESC
}

type ReviewPreviousValues {
  id: ID!
  stars: Int!
  commentary: String
}

input ReviewScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  commentary: String
  commentary_not: String
  commentary_in: [String!]
  commentary_not_in: [String!]
  commentary_lt: String
  commentary_lte: String
  commentary_gt: String
  commentary_gte: String
  commentary_contains: String
  commentary_not_contains: String
  commentary_starts_with: String
  commentary_not_starts_with: String
  commentary_ends_with: String
  commentary_not_ends_with: String
  AND: [ReviewScalarWhereInput!]
  OR: [ReviewScalarWhereInput!]
  NOT: [ReviewScalarWhereInput!]
}

type ReviewSubscriptionPayload {
  mutation: MutationType!
  node: Review
  updatedFields: [String!]
  previousValues: ReviewPreviousValues
}

input ReviewSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReviewWhereInput
  AND: [ReviewSubscriptionWhereInput!]
  OR: [ReviewSubscriptionWhereInput!]
  NOT: [ReviewSubscriptionWhereInput!]
}

input ReviewUpdateInput {
  stars: Int
  commentary: String
  author: UserUpdateOneRequiredWithoutReviewsInput
  interview: InterviewUpdateOneRequiredWithoutReviewsInput
}

input ReviewUpdateManyDataInput {
  stars: Int
  commentary: String
}

input ReviewUpdateManyMutationInput {
  stars: Int
  commentary: String
}

input ReviewUpdateManyWithoutAuthorInput {
  create: [ReviewCreateWithoutAuthorInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithoutInterviewInput {
  create: [ReviewCreateWithoutInterviewInput!]
  delete: [ReviewWhereUniqueInput!]
  connect: [ReviewWhereUniqueInput!]
  set: [ReviewWhereUniqueInput!]
  disconnect: [ReviewWhereUniqueInput!]
  update: [ReviewUpdateWithWhereUniqueWithoutInterviewInput!]
  upsert: [ReviewUpsertWithWhereUniqueWithoutInterviewInput!]
  deleteMany: [ReviewScalarWhereInput!]
  updateMany: [ReviewUpdateManyWithWhereNestedInput!]
}

input ReviewUpdateManyWithWhereNestedInput {
  where: ReviewScalarWhereInput!
  data: ReviewUpdateManyDataInput!
}

input ReviewUpdateWithoutAuthorDataInput {
  stars: Int
  commentary: String
  interview: InterviewUpdateOneRequiredWithoutReviewsInput
}

input ReviewUpdateWithoutInterviewDataInput {
  stars: Int
  commentary: String
  author: UserUpdateOneRequiredWithoutReviewsInput
}

input ReviewUpdateWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutAuthorDataInput!
}

input ReviewUpdateWithWhereUniqueWithoutInterviewInput {
  where: ReviewWhereUniqueInput!
  data: ReviewUpdateWithoutInterviewDataInput!
}

input ReviewUpsertWithWhereUniqueWithoutAuthorInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutAuthorDataInput!
  create: ReviewCreateWithoutAuthorInput!
}

input ReviewUpsertWithWhereUniqueWithoutInterviewInput {
  where: ReviewWhereUniqueInput!
  update: ReviewUpdateWithoutInterviewDataInput!
  create: ReviewCreateWithoutInterviewInput!
}

input ReviewWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  commentary: String
  commentary_not: String
  commentary_in: [String!]
  commentary_not_in: [String!]
  commentary_lt: String
  commentary_lte: String
  commentary_gt: String
  commentary_gte: String
  commentary_contains: String
  commentary_not_contains: String
  commentary_starts_with: String
  commentary_not_starts_with: String
  commentary_ends_with: String
  commentary_not_ends_with: String
  author: UserWhereInput
  interview: InterviewWhereInput
  AND: [ReviewWhereInput!]
  OR: [ReviewWhereInput!]
  NOT: [ReviewWhereInput!]
}

input ReviewWhereUniqueInput {
  id: ID
}

type Sauce {
  id: ID!
  name: String!
  scoville: Int!
  appearsIn(where: InterviewWhereInput, orderBy: InterviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Interview!]
}

type SauceConnection {
  pageInfo: PageInfo!
  edges: [SauceEdge]!
  aggregate: AggregateSauce!
}

input SauceCreateInput {
  id: ID
  name: String!
  scoville: Int!
  appearsIn: InterviewCreateManyWithoutSaucesInput
}

input SauceCreateManyWithoutAppearsInInput {
  create: [SauceCreateWithoutAppearsInInput!]
  connect: [SauceWhereUniqueInput!]
}

input SauceCreateWithoutAppearsInInput {
  id: ID
  name: String!
  scoville: Int!
}

type SauceEdge {
  node: Sauce!
  cursor: String!
}

enum SauceOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  scoville_ASC
  scoville_DESC
}

type SaucePreviousValues {
  id: ID!
  name: String!
  scoville: Int!
}

input SauceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  scoville: Int
  scoville_not: Int
  scoville_in: [Int!]
  scoville_not_in: [Int!]
  scoville_lt: Int
  scoville_lte: Int
  scoville_gt: Int
  scoville_gte: Int
  AND: [SauceScalarWhereInput!]
  OR: [SauceScalarWhereInput!]
  NOT: [SauceScalarWhereInput!]
}

type SauceSubscriptionPayload {
  mutation: MutationType!
  node: Sauce
  updatedFields: [String!]
  previousValues: SaucePreviousValues
}

input SauceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SauceWhereInput
  AND: [SauceSubscriptionWhereInput!]
  OR: [SauceSubscriptionWhereInput!]
  NOT: [SauceSubscriptionWhereInput!]
}

input SauceUpdateInput {
  name: String
  scoville: Int
  appearsIn: InterviewUpdateManyWithoutSaucesInput
}

input SauceUpdateManyDataInput {
  name: String
  scoville: Int
}

input SauceUpdateManyMutationInput {
  name: String
  scoville: Int
}

input SauceUpdateManyWithoutAppearsInInput {
  create: [SauceCreateWithoutAppearsInInput!]
  delete: [SauceWhereUniqueInput!]
  connect: [SauceWhereUniqueInput!]
  set: [SauceWhereUniqueInput!]
  disconnect: [SauceWhereUniqueInput!]
  update: [SauceUpdateWithWhereUniqueWithoutAppearsInInput!]
  upsert: [SauceUpsertWithWhereUniqueWithoutAppearsInInput!]
  deleteMany: [SauceScalarWhereInput!]
  updateMany: [SauceUpdateManyWithWhereNestedInput!]
}

input SauceUpdateManyWithWhereNestedInput {
  where: SauceScalarWhereInput!
  data: SauceUpdateManyDataInput!
}

input SauceUpdateWithoutAppearsInDataInput {
  name: String
  scoville: Int
}

input SauceUpdateWithWhereUniqueWithoutAppearsInInput {
  where: SauceWhereUniqueInput!
  data: SauceUpdateWithoutAppearsInDataInput!
}

input SauceUpsertWithWhereUniqueWithoutAppearsInInput {
  where: SauceWhereUniqueInput!
  update: SauceUpdateWithoutAppearsInDataInput!
  create: SauceCreateWithoutAppearsInInput!
}

input SauceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  scoville: Int
  scoville_not: Int
  scoville_in: [Int!]
  scoville_not_in: [Int!]
  scoville_lt: Int
  scoville_lte: Int
  scoville_gt: Int
  scoville_gte: Int
  appearsIn_every: InterviewWhereInput
  appearsIn_some: InterviewWhereInput
  appearsIn_none: InterviewWhereInput
  AND: [SauceWhereInput!]
  OR: [SauceWhereInput!]
  NOT: [SauceWhereInput!]
}

input SauceWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  interview(where: InterviewSubscriptionWhereInput): InterviewSubscriptionPayload
  review(where: ReviewSubscriptionWhereInput): ReviewSubscriptionPayload
  sauce(where: SauceSubscriptionWhereInput): SauceSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String!
  password: String!
  handle: String!
  reviews(where: ReviewWhereInput, orderBy: ReviewOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Review!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  handle: String!
  reviews: ReviewCreateManyWithoutAuthorInput
}

input UserCreateOneWithoutReviewsInput {
  create: UserCreateWithoutReviewsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutReviewsInput {
  id: ID
  email: String!
  password: String!
  handle: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  handle_ASC
  handle_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  handle: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  handle: String
  reviews: ReviewUpdateManyWithoutAuthorInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  handle: String
}

input UserUpdateOneRequiredWithoutReviewsInput {
  create: UserCreateWithoutReviewsInput
  update: UserUpdateWithoutReviewsDataInput
  upsert: UserUpsertWithoutReviewsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutReviewsDataInput {
  email: String
  password: String
  handle: String
}

input UserUpsertWithoutReviewsInput {
  update: UserUpdateWithoutReviewsDataInput!
  create: UserCreateWithoutReviewsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  handle: String
  handle_not: String
  handle_in: [String!]
  handle_not_in: [String!]
  handle_lt: String
  handle_lte: String
  handle_gt: String
  handle_gte: String
  handle_contains: String
  handle_not_contains: String
  handle_starts_with: String
  handle_not_starts_with: String
  handle_ends_with: String
  handle_not_ends_with: String
  reviews_every: ReviewWhereInput
  reviews_some: ReviewWhereInput
  reviews_none: ReviewWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    